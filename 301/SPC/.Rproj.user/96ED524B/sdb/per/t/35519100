{
    "contents" : "setwd(\"C:/Users/Rod/SkyDrive/R/301/SPC\")\n\n#------------------------------------------------------------------------------\n#' classifyByWesternElectricRuleZones.numeric\n#' @param x a vector of numeric values that are to be classified into Western Electric Rule zones\n#' @param x.bar the mean value to be used for classification.  Is NULL by default.  Calculated as necessary.\n#' @param sigma the standard deviation to be used for classification.  Is NULL by default.  Calculated as necessary.\n#' @return a vector with these positive/negative values: |4| = outlier, |3| = zone A, |2| = zone B, |1| = zone C, 0 = x.bar\n#' @examples x = c(3.1, 2.1, 1.1, 0.1, 0, -0.1, -1.1, -2.1, -3.1)\n#' @examples x.bar = 0\n#' @examples sigma = 1\n#' @examples xclass = classifyByWesternElectricRuleZones.numeric(x, x.bar, sigma)\n#' @examples (xclass)\n#' @examples [1]  4  3  2  1  0 -1 -2 -3 -4\nclassifyByWesternElectricRuleZones.numeric <- function(x, x.bar = NULL, sigma = NULL) {\n  if (is.null(x.bar) || is.null(sigma)) {\n\tx.bar = mean(x)\n\tsigma = sd(x)\n  }\n\n  # Identify the zone of each point.\t\n  gt.pos.three.sigma = which(x > (x.bar + (3 * sigma)))\n  gt.pos.two.sigma = which(x > (x.bar + (2 * sigma)))\n  gt.pos.one.sigma = which(x > (x.bar + sigma))\n  gt.xbar = which(x > x.bar)\n  eq.xbar = which(x == x.bar)\n  lt.x.bar = which(x < x.bar)\n  lt.neg.one.sigma = which(x < (x.bar - sigma))\n  lt.neg.two.sigma = which(x < (x.bar - (2 * sigma)))\n  lt.neg.three.sigma = which(x < (x.bar - (3 * sigma)))\n   \n  outliers = union(gt.pos.three.sigma, lt.neg.three.sigma)\n  \n  pos.A = setdiff(gt.pos.two.sigma, gt.pos.three.sigma)\n  pos.B = setdiff(gt.pos.one.sigma, gt.pos.two.sigma)\n  pos.C = setdiff(gt.xbar, gt.pos.one.sigma)\n  \n  neg.C = setdiff(lt.x.bar, lt.neg.one.sigma)\n  neg.B = setdiff(lt.neg.one.sigma, lt.neg.two.sigma)\n  neg.A = setdiff(lt.neg.two.sigma, lt.neg.three.sigma)\n  \n  zones = numeric(length(x))\n  zones[gt.pos.three.sigma] = 4\n  zones[pos.A] = 3\n  zones[pos.B] = 2\n  zones[pos.C] = 1\n  zones[eq.xbar] = 0\n  zones[neg.C] = -1\n  zones[neg.B] = -2\n  zones[neg.A] = -3\n  zones[lt.neg.three.sigma] = -4 \n\n  return(zones);\n}\n\n# x = c(3.1, 3.0,  2.1, 2.0, 1.1, 1.0,  0.1, 0, -0.1, -1.0, -1.1, -2.0, -2.1, -3.0, -3.1)\n# x.bar = 0\n# sigma = 1\n# xclass = classifyByWesternElectricRuleZones.numeric(x, x.bar, sigma)\n# (xclass)\n\n#------------------------------------------------------------------------------\n#' classifyByWesternElectricRuleZones\n#' @param x a vector of numeric values that are to be classified into Western Electric Rule zones\n#' @param x.bar the mean value to be used for classification.  Is NULL by default.  Calculated as necessary.\n#' @param sigma the standard deviation to be used for classification.  Is NULL by default.  Calculated as necessary.\n#' @return a vector with these values: 'O' = outlier, 'A' = zone A, 'B' = zone B, 'C' = zone C\n#' @examples x = c(3.1, 2.1, 1.1, 0.1, 0, -0.1, -1.1, -2.1, -3.1)\n#' @examples x.bar = 0\n#' @examples sigma = 1\n#' @examples xclass = classifyByWesternElectricRuleZones(x, x.bar, sigma)\n#' @examples (xclass)\n#' @examples [1] \"O\" \"A\" \"B\" \"C\" \"C\" \"C\" \"B\" \"A\" \"O\"\nclassifyByWesternElectricRuleZones <- function(x, x.bar=NULL, sigma=NULL) {\n  zones.numeric = classifyByWesternElectricRuleZones.numeric(x, x.bar, sigma)\n  \n  zone.A = union(which(zones.numeric == 3), which(zones.numeric == -3))\n  zone.B = union(which(zones.numeric == 2), which(zones.numeric == -2))\n  zone.C = union(which(zones.numeric == 1), which(zones.numeric == -1))\n  zone.C = union(zone.C, which(zones.numeric == 0))\n  zone.Outlier = union(which(zones.numeric == 4), which(zones.numeric == -4))\n  \n  zones = character(length(x))\n  zones[zone.A] = 'A'\n  zones[zone.B] = 'B'\n  zones[zone.C] = 'C'\n  zones[zone.Outlier] = 'O'  \n\n  return(zones); \n}\n\n# x = c(3.1, 2.1, 1.1, 0.1, 0, -0.1, -1.1, -2.1, -3.1)\n# x = c(3.1, 3.0,  2.1, 2.0, 1.1, 1.0,  0.1, 0, -0.1, -1.0, -1.1, -2.0, -2.1, -3.0, -3.1)\n# x.bar = 0\n# sigma = 1\n# xclass = classifyByWesternElectricRuleZones(x, x.bar, sigma)\n# (xclass)\n\n#------------------------------------------------------------------------------\n#' logWesternElectricRuleViolation\n#' @param results a (possibly empty) dataframe with these numeric columns:  idxInitial, idxFinal, rule\n#' @param idxInitial the index of the value in the source vector where a violation was initially detected\n#' @param idxFinal the index of the value in the source vector where the violation was last detected\n#' @param rule the Western Electric Rule number that was violated in the range idxInitial:idxFinal (inclusive)\n#' @return the original results dataframe with one additional row added to it\n#' @examples results <- data.frame(idxInitial = numeric(), idxFinal = numeric(), rule = numeric())\n#' @examples results <- logWesternElectricRuleViolation(results, 5, 5, 1)\n#' @examples results <- logWesternElectricRuleViolation(results, 2, 4, 2) \n#' @examples results <- logWesternElectricRuleViolation(results, 6, 10, 3)\n#' @examples results <- logWesternElectricRuleViolation(results, 11, 19, 4)\n#' @examples (results) \nlogWesternElectricRuleViolation <- function(results, idxInitial, idxFinal, rule) {\n\tresult <- data.frame(idxInitial=idxInitial, idxFinal=idxFinal, rule=rule)\n\tresults <- rbind(results, result)\n\t\n\treturn(results);\n} \t\n\n# results <- data.frame(idxInitial = numeric(), idxFinal = numeric(), rule = numeric())\n# results <- logWesternElectricRuleViolation(results, 5, 5, 1)\n# results <- logWesternElectricRuleViolation(results, 2, 4, 2) \n# results <- logWesternElectricRuleViolation(results, 6, 10, 3)\n# results <- logWesternElectricRuleViolation(results, 11, 19, 4)\n# (results)\n\n#------------------------------------------------------------------------------\n#' findWesternElectricRuleViolations\n#' @param x a vector of numeric values that are to be classified into Western Electric Rule zones\n#' @param x.bar the mean value to be used for classification.  Is NULL by default.  Calculated as necessary.\n#' @param sigma the standard deviation to be used for classification.  Is NULL by default.  Calculated as necessary.\n#' @return a (possibly empty) dataframe with these numeric columns:  idxInitial, idxFinal, rule\nfindWesternElectricRuleViolations <- function(x, x.bar = NULL, sigma = NULL) {\n\tif (is.null(x.bar) || is.null(sigma)) {\n\t\tx.bar = mean(x)\n\t\tsigma = sd(x)\n    }\n\t\n\t # Create an empty dataframe to store results.\n\tresults <- data.frame(idxInitial = numeric(), idxFinal = numeric(), rule = numeric())\n\t\n\tnItems = length(x)\n\tzones.numeric = classifyByWesternElectricRuleZones.numeric(x, x.bar, sigma)\n\t\n\t#--------------------------------------------------------------------------\n\t# Test for Rule 4 violation.\n\t# This is 9 consecutive points that fall on the same side\n\t# of the centerline (Zone C or beyond).\n\t#--------------------------------------------------------------------------\n\tminRunLen = 9\n\tfor (idxInitial in 1:(nItems - minRunLen + 1)) {\n\t\n\t\tidxFinal = (idxInitial + minRunLen - 1)\n\t\n\t\tif ( (all(zones.numeric[idxInitial:idxFinal] > 0)) ||\n\t\t     (all(zones.numeric[idxInitial:idxFinal] < 0)) )\n\t\t{\n\t\t\tresults = logWesternElectricRuleViolation(results, idxInitial, idxFinal, 4)\n\t\t}\n\t}\n\t\n\t#--------------------------------------------------------------------------\n\t# Test for Rule 3 violation.\n\t# This is 4 out of 5 points that fall beyond the 1 sigma\n\t# limit (Zone B or beyond) on the same side of the centerline.\n\t#--------------------------------------------------------------------------\n\tminRunLen = 5\n\tfor (idxInitial in 1:(nItems - minRunLen + 1)) \n\t{\n\t\tidxFinal = (idxInitial + minRunLen - 1)\n\t\t\t\n\t\t# Do an initial screen to determine if any points are in zone B\n\t\tif ( (any(zones.numeric[idxInitial:idxFinal] > 1)) ||\n\t\t\t (any(zones.numeric[idxInitial:idxFinal] < -1)) ) \n\t\t{\t \n\t\t\t# Some of the data in the range are in zone B.  Investigate.\n\t\t\tcountZoneB = 0\n\t\t\tcountOpposite = 0\n\t\t\tmatched = 0\n\t\t\t\n\t\t\t# Test the positive case.\n\t\t\tfor (i in idxInitial:idxFinal) {\n\t\t\t\tif (zones.numeric[i] > 1) { countZoneB = countZoneB + 1 }\n\t\t\t\telse if (zones.numeric[i] < 0) { countOpposite = countOpposite + 1 }\n\t\t\t}\n\t\t\t\n\t\t\t# Did it match?\n\t\t\tif ((countZoneB == 4) && (countOpposite == 1)) {\n\t\t\t\tmatched = 1\n\t\t\t}\n\t\t\t\n\t\t\t# If not matched, test the negative case.\n\t\t\tif (matched == 0) {\n\t\t\t\tcountZoneB = 0\n\t\t\t\tcountOpposite = 0\n\t\t\t\t\n\t\t\t\tfor (i in idxInitial:idxFinal) {\n\t\t\t\t\tif (zones.numeric[i] < -1) { countZoneB = countZoneB + 1 }\n\t\t\t\t\telse if (zones.numeric[i] > 0) { countOpposite = countOpposite + 1 }\n\t\t\t\t\t\n\t\t\t\t\tif ((countZoneB == 4) && (countOpposite == 1)) {\n\t\t\t\t\t\tmatched = 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n            \n\t\t\t# If positive or negative match detected, log it.\n\t\t\tif (matched == 1) { \n\t\t\t\tresults = logWesternElectricRuleViolation(results, idxInitial, idxFinal, 3) \n\t\t\t}\t\n\t\t}\n\t}\n\t\n\t#--------------------------------------------------------------------------\n\t# Test for Rule 2 violation.\n\t# This is 2 out of 3 consecutive points that fall beyond the 2 sigma\n\t# limit (Zone B or beyond) on the same side of the centerline.\n\t#--------------------------------------------------------------------------\n\tminRunLen = 3\n\tfor (idxInitial in 1:(nItems - minRunLen + 1)) \n\t{\n\t\tidxFinal = (idxInitial + minRunLen - 1)\n\t\t\t\n\t\t# Do an initial screen to determine if any points are in zone A\n\t\tif ( (any(zones.numeric[idxInitial:idxFinal] > 2)) ||\n\t\t\t (any(zones.numeric[idxInitial:idxFinal] < -2)) ) \n\t\t{\t \n\t\t\t# Some of the data in the range are in zone A.  Investigate.\n\t\t\tcountZoneA = 0\n\t\t\tcountSameSide = 0\n\t\t\tmatched = 0\n\t\t\t\n\t\t\t# Test the positive case.\n\t\t\tfor (i in idxInitial:idxFinal) {\n\t\t\t\tif (zones.numeric[i] > 2) { countZoneA = countZoneA + 1 }\n\t\t\t\telse if (zones.numeric[i] > 0) { countSameSide = countSameSide + 1 }\n\t\t\t}\n\t\t\t\n\t\t\t# Did it match?\n\t\t\tif ((countZoneA == 2) && (countSameSide == 1)) {\n\t\t\t\tmatched = 1\n\t\t\t}\n\t\t\t\n\t\t\t# If not matched, test the negative case.\n\t\t\tif (matched == 0) {\n\t\t\t\tcountZoneA = 0\n\t\t\t\tcountSameSide = 0\n\t\t\t\t\n\t\t\t\tfor (i in idxInitial:idxFinal) {\n\t\t\t\t\tif (zones.numeric[i] < -2) { countZoneA = countZoneA + 1 }\n\t\t\t\t\telse if (zones.numeric[i] < 0) { countSameSide = countSameSide + 1 }\n\t\t\t\t\t\n\t\t\t\t\tif ((countZoneB == 2) && (countSameSide == 1)) {\n\t\t\t\t\t\tmatched = 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t# If positive or negative match detected, log it.\n\t\t\tif (matched == 1) { \n\t\t\t\tresults = logWesternElectricRuleViolation(results, idxInitial, idxFinal, 2) \n\t\t\t}\t\n\t\t}\t\n\t}\n\t\n\t#--------------------------------------------------------------------------\n\t# Test for Rule 1 violation.\n\t# This is any point that falls beyond the 3 sigma limit (Zone C or beyond).\n\t#--------------------------------------------------------------------------\n\tviolations = sort(union(which(zones.numeric == 4), which(zones.numeric == -4)))\n\tif (length(violations) > 0) {\n\t\tfor (i in 1:length(violations)) {\n\t\t\tresults = logWesternElectricRuleViolation(results, violations[i], violations[i], 1)\n\t\t}\n\t}\n\treturn(results);\n}\n \n# x.bar = 0 \n# sigma = 1\t\n# x = c(0, 1.1,1.2,1.1,  1.3,1.4,1.3, 1.4,1.5,1.4, 0,  1.1,-1.0,1.1,1.2,1.1, 0.0, 2.2,1.1,2.3, 0, 4.1, -4.1)\n\n# results =  findWesternElectricRuleViolations(x, x.bar, sigma)\n# (results)\n\n#------------------------------------------------------------------------------\n#' plotSpcChart\n#' @param batchAverages a vector of numeric values that contains the average value of a series of batches. \n#' @param batchRanges a vector of numeric values that contains the range of value of a series of batches.  Must be of the same length as batchAverages. \n#' @param x.bar.batchAverages the mean value to be used for classification of batchAverages.  Is NULL by default.  Calculated as necessary.\n#' @param sigma.batchAverages the standard deviation value to be used for classification of batchAverages.  Is NULL by default.  Calculated as necessary.\n#' @param x.bar.batchRanges the mean value to be used for classification of batchAverages.  Is NULL by default.  Calculated as necessary.\n#' @param sigma.batchRanges the standard deviation value to be used for classification of batchRanges.  Is NULL by default.  Calculated as necessary.\n#' @param sigma the standard deviation to be used for classification of batchRanges.  Is NULL by default.  Calculated as necessary.\n#' @return a dataframe with these numeric columns:  batchAverage, state.batchAverage, batchRange, state.batchRange\nplotSpcChart <- function(batchAverages, batchRanges, x.bar.batchAverages = NULL, sigma.batchAverages = NULL, x.bar.batchRanges = NULL, sigma.batchRanges = NULL)\n{\n\tif ((is.null(x.bar.batchAverages)) || (is.null(sigma.batchAverages)) ) {\n\t\tx.bar.batchAverages = mean(batchAverages)\n\t\tsigma.batchAverages = sd(batchAverages)\n\t}\n\t\n\tif ((is.null(x.bar.batchRanges)) || (is.null(sigma.batchRanges))) {\n\t\tx.bar.batchRanges = mean(batchRanges)\n\t\tsigma.batchRanges = sd(batchRanges)\n\t}\n\t\n\t# Find SPC violations in batch averages.\n\tspc.violations.batchAverages =  findWesternElectricRuleViolations(batchAverages, x.bar.batchAverages, sigma.batchAverages)\n\t\n\t# Find SPC violations in batch ranges.\n\tspc.violations.batchRanges =  findWesternElectricRuleViolations(batchRanges, x.bar.batchRanges, sigma.batchRanges)\n\t\n\t# Create a vector of all batch average SPC states.  Set state (rule) to 0 by default.\n\tspc.state.batchAverages = rep(0, length(batchAverages))\n\tif (length(spc.violations.batchAverages[,1]) > 0) {\n\t\tfor( i in 1:length(spc.violations.batchAverages[,1])) {\n\t\t\tspc.state.batchAverages[spc.violations.batchAverages$idxInitial[i]:spc.violations.batchAverages$idxFinal[i]] = spc.violations.batchAverages$rule[i]\n\t\t}\n\t}\n\t\n\t# Create a vector of all batch range SPC states.  Set state (rule) to 0 by default.\n\tspc.state.batchRanges = rep(0, length(batchRanges))\n\tif (length(spc.violations.batchRanges[,1]) > 0) {\n\t\tfor( i in 1:length(spc.violations.batchRanges[,1])) {\n\t\t\tspc.state.batchRanges[spc.violations.batchRanges$idxInitial[i]:spc.violations.batchRanges$idxFinal[i]] = spc.violations.batchRanges$rule[i]\n\t\t}\n\t}\n\t\t\n\t# Create a dataframe of values and SPC states.\n\tspcData = data.frame(batchAverage = numeric(), state.batchAverage = numeric() ) #, batchRange=numeric(), state.batchRange=numeric())\n\tfor (i in 1:length(batchAverages)) {\n\t\tnextRow = data.frame(\tbatchAverage=batchAverages[i], \n\t\t\t\t\t\t\t\tstate.batchAverage=spc.state.batchAverages[i],\n\t\t\t\t\t\t\t\tbatchRange=batchRanges[i],\n\t\t\t\t\t\t\t\tstate.batchRange=spc.state.batchRanges[i] )\n\t\tspcData <- rbind(spcData, nextRow)\n\t}\n\n\t# Colors to use in plots.\n\t#            black           green              yellow          orange            red         purple\n\t# cols = c(rgb(0,0,0,0.4), rgb(0,0,1,0.4), rgb(1,1,0,0.4), rgb(1,0.6,0,0.4), rgb(0,0,1,0.4), rgb(1,0,1,0.4))\n\t#            green           yellow          orange            red             purple\n\tcols = c(rgb(0,1,0,0.6), rgb(1,1,0,0.6), rgb(1,0.6,0,0.6), rgb(0,0,1,0.6), rgb(1,0,1,0.6))\n\tprevOp <- par(fig=c(0,1,0.5,1))\n\tpar(mar=c(0,5,2,2))\n\tpar(cex=0.64)\n\t\t \n\tplot(spcData$batchAverage, col=cols[spcData$state.batchAverage + 1], \n\t\txlab=\"\", \n\t\txaxt=\"n\", \n\t\ttype=\"b\",\n\t\tmain=\"SPC Chart\",\n\t\tylab=\"Batch Averages\", \n\t\tpch=19)\n\tlegend(\"topleft\", horiz=TRUE, legend=c(\"In Control\", \"Rule 1\", \"Rule 2\", \"Rule 3\", \"Rule 4\"), col=cols, pch=19)\n\tabline(h = x.bar.batchAverages)\t\n\tabline(h = (x.bar.batchAverages + (1 * sigma.batchAverages)), lty=\"dashed\", col=rgb(0,0,0,0.4))\n\tabline(h = (x.bar.batchAverages + (2 * sigma.batchAverages)), lty=\"dashed\", col=rgb(0,0,0,0.4))\n\tabline(h = (x.bar.batchAverages + (3 * sigma.batchAverages)), lty=\"dashed\", col=rgb(0,0,0,0.4))\n\tabline(h = (x.bar.batchAverages - (1 * sigma.batchAverages)), lty=\"dashed\", col=rgb(0,0,0,0.4))\n\tabline(h = (x.bar.batchAverages - (2 * sigma.batchAverages)), lty=\"dashed\", col=rgb(0,0,0,0.4))\n\tabline(h = (x.bar.batchAverages - (3 * sigma.batchAverages)), lty=\"dashed\", col=rgb(0,0,0,0.4))\n\t\t\n\tpar(fig=c(0,1,0,0.5), new=TRUE)\n\tpar(mar=c(5,5,0,2))\n\t\n\tplot(spcData$batchRange, col=cols[spcData$state.batchRange + 1], \n\t\txlab=\"\",\n\t\tylab=\"Batch Ranges\",\n\t\ttype=\"b\",\t\n\t\tpch=19)\n\tabline(h = x.bar.batchRanges)\t\n\tabline(h = (x.bar.batchRanges + (1 * sigma.batchRanges)), lty=\"dashed\", col=rgb(0,0,0,0.4))\n\tabline(h = (x.bar.batchRanges + (2 * sigma.batchRanges)), lty=\"dashed\", col=rgb(0,0,0,0.4))\n\tabline(h = (x.bar.batchRanges + (3 * sigma.batchRanges)), lty=\"dashed\", col=rgb(0,0,0,0.4))\n\tabline(h = (x.bar.batchRanges - (1 * sigma.batchRanges)), lty=\"dashed\", col=rgb(0,0,0,0.4))\n\tabline(h = (x.bar.batchRanges - (2 * sigma.batchRanges)), lty=\"dashed\", col=rgb(0,0,0,0.4))\n\tabline(h = (x.bar.batchRanges - (3 * sigma.batchRanges)), lty=\"dashed\", col=rgb(0,0,0,0.4))\n\t\t\n\tpar(prevOp)\n\t\n\treturn(spcData)\n}\t\n\nbatchAverages = c(0, 1.1,1.2,1.1,  1.3,1.4,1.3, 1.4,1.5,1.4,   0,  1.1,-1,1.1,1.2,1.1,   0,  2.2,1.1,2.3,   0,   4.1, -4.1)\nx.bar.batchAverages = 0 \nsigma.batchAverages = 1\n\nbatchRanges = numeric(length(batchAverages))\nx.bar.batchRanges = 10\nsigma.batchRanges = 1.0\nfor (i in 1:length(batchRanges)) { batchRanges[i] = x.bar.batchRanges + rnorm(1, 0, 0.5) }\n\nspcSampleData = plotSpcChart(batchAverages, batchRanges, x.bar.batchAverages, sigma.batchAverages, x.bar.batchRanges, sigma.batchRanges)\n\nrm(i)\nrm(batchAverages)\nrm(x.bar.batchAverages)\nrm(sigma.batchAverages)\n\nrm(batchRanges)\nrm(x.bar.batchRanges)\nrm(sigma.batchRanges)\n\n\n#------------------------------------------------------------------------------\n\t\n\t",
    "created" : 1371325469421.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2606206592",
    "id" : "35519100",
    "lastKnownWriteTime" : 1371325288,
    "path" : "C:/Users/Rod/SkyDrive/R/301/SPC/WesternElectricRulesSPC.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}